ולכן תמיד נתחיל קוד חדש עם אפס פונקציונליות. במילים אחרות, נשאף לייצר גרסה שכמעט לא עושה שום דבר אבל מתקמפלת, רצה ועובדת כצפוי. עכשיו, במקום לקרוא את זה, אתם צריכים ללכת לבצע את הצעדים הבאים:

צרו תיקיה חדשה למשחק. נרצה שיטת main כדי לבדוק את הקוד תוך כדי כתיבה. Game היא המחלקה שבה תהיה שיטת ה-main בסופו של דבר, ולכן כנראה תרצו לפתוח קובץ (ומחלקה) של Game וליצור שם אתpublic static void main(String[] args)i.
קמפלו את Game.java (בלי Renderer) והריצו אותו! אם אתם לא זוכרים מה זה בדיוק javac או java או איך להשתמש ב-console - ראו את "הוראות העבודה עם הטרמינל" במדריך ההתקנות.
הכריזו על ה-enum בשם Mark ע"פ דרישות קיימות מ-Board. המיקום ההגיוני ל-enum הוא בקובץ משלו או בתוך Board.java, ובכל מקרה שימו לב לא לשים אותו בתוך מחלקה אחרת. ניתן להגדיר enum ומחלקה באותו הקובץ אחד אחרי השני.
כתבו את מחלקת ה-Board הפשוטה והמינימלית ביותר שעדיין טכנית ממלאת את שלוש הדרישות של Renderer. חוץ מזה, היא לא עושה שום דבר בפועל! לדוגמה, getMark יכולה תמיד להחזיר את X או BLANK לצורך העניין. מימוש כזה נקרא stub. stub לא עושה שום דבר חוץ מלגרום לחלק אחר בקוד להתקמפל ולרוץ. אל תשכחו לקמפל אחרי כל שורה או פעם בכמה שורות קוד.
הוסיפו את מחלקת Renderer לתיקיה, וודאו ששלוש המחלקות מתקמפלות ביחד. אם Renderer לא מתקמפלת בידקו אם שלוש הדרישות שלה מתקיימות ואם גירסת ה-java שלכם היא 10 ומעלה.
השתמשו ב-Renderer וב-Board המינימלי כדי להציג לוח.
אחרי הקימפול, הריצו את הקוד באמצעות Game. אם הכל יעבוד כשורה, יוצג לוח בגודל SIZE x SIZE כאשר כל התאים הם X (או O, או ריקים - תלוי במימוש המינימלי של Board).



מימוש epsilon-functionality
עכשיו כשיש לכם מימוש עם אפס פונקציונליות, אפשר על בסיסו למלא את המתודות putMark ו-getMark (בתוספת שיטות ושדות פרטיים לפי הצורך), כך שהן באמת יבצעו את הפעולות שהן מחויבות אליהן. לא בטוחים איך לבצע את זה? הציצו בטיפי המימוש!



מתוך ה-main אתם אמורים להצליח בשלב זה ליצור לוח, לקרוא ל-putMark כמה פעמים ולהציג את הלוח שמילאתם. כיתבו stub-ים עבור שאר השיטות במחלקת Board שאמורות לקבוע אם המשחק נגמר ואיך. כרגע זה יספיק לנו, ונוכל לחזור בהמשך למימוש של Board ברגע ששלד המשחק יהיה בנוי.

בידקו את הקוד שלכם!



תפקידי מחלקת Player

בשלב זה יש לנו שיטת main, מחלקת Renderer, לוח חלקי ותמונה כללית של ה-API שלהם. נמשיך בתיאור ה-API של Player.

הפרט החשוב ביותר שאליו צריך לשים לב ב-Player:

אם נחשוב על דרכים לפתח את המשחק שלנו אחרי שנסיים לכתוב אותו בצורתו הנוכחית, זו המחלקה הראשונה שנרצה להרחיב. כן, כרגע היא מייצגת שחקן אנושי (המשתמש/ת), אבל יכול להיות שנרצה לשנות את המשחק כך שהיא תייצג שחקן אוטומטי.

לכן, מחלקת ה-Player תכמס (encapsulate) את הקלט מהמשתמש/ת: כל מה שקשור לקלט יהיה מוכל במחלקה, ה-API יהיה מופשט, ולא יחשוף מידע לגבי פרטי המימוש שמאחוריו.



-------------------------


ה-API של Player
ה-API של Player מסתמך על החלטה חשובה אחת, והיא מה מופע של Player מייצג עבור שאר המחלקות. קיימות שתי אפשרויות מרכזיות:

השחקן מייצג לוגיקה או אסטרטגיה מסוימות לביצוע תור במשחק בהינתן לוח מסוים. דוגמה אחת לאסטרטגיה היא לשאול את המשתמש/ת איזה צעד ירצו. במקרה זה, השחקן לא תלוי במשחק מסוים; מופע אחד של שחקן יכול לקחת חלק במשחק אחד או בכמה, ועם סימונים שונים.
השחקן מייצג צד אחד (X או O) במשחק ספציפי, ובהתאם הוא כבול ללוח ולסימון יחידים. בגישה זו, לכל משחק ומשחק (לו היה יותר מאחד) יווצר זוג מופעים של שחקנים חדשים.
שתי הגישות תקינות והגיוניות, אבל האופציה הראשונה תתאים יותר למטרות התרגיל הנוכחי (וגם הבא). כתוצאה מכך, הבנאי של Player לא דורש שום קלט, היות ולא נדרש אף מידע לגבי המשחק או הלוח כדי לאתחל את השחקן.

מה שנצטרך ש-Player יעשה בפועל הוא ביצוע תור יחיד, כלומר ימקם את סימון על הלוח בעזרת Board.putMark ע"פ לוגיקה מסוימת (במקרה שלנו - הלוגיקה היא בקשת קלט מהמשתמש/ת). נעשה זאת בשיטה בשם playTurn, שצריכה לוח וסימון כדי לפעול, ולכן הם יהיו הפרמטרים שלה.

נשארנו עם שאלה חשובה: איך לדעתכם צריכה playTurn להתמודד עם קבלת קואורדינטות לא חוקיות מהמשתמש/ת, או קואורדינטות שמציינות מקום שכבר תפוס?

הדפסת הודעת שגיאה ויציאה מהתוכנית.
הודעה לשיטה שקראה לה (ה"לקוחה" של מחלקת Player) שהתרחשה שגיאה.
התעקשות לקבלת קלט תקין מהמשתמש עד שהוא מזין קואורדינטות שכן חוקיות.
בחירת קואורדינטות אחרות, שכן חוקיות לצעד הנוכחי, במקום הקואורדינטות הלא-חוקיות שהוזנו ע"י המשתמש/ת.
התשובה לשאלה הזו מיתרגמת ישירות לערך ההחזרה הנדרש של playTurn, משום שערך ההחזרה הוא הדרך של השיטה למסור מידע חזרה ללקוח שלה. באופציות 1, 3 ו-4 אין בעצם מה להחזיר - זו תהיה שיטה שמחזירה void. בחירה באופציה 2 משמעותה שיהיה ערך החזרה לפונקציה, לדוגמה ערך בוליאני.

בניגוד להחלטות עיצוב אחרות שנתקלתם בהם, זו לא החלטה שתלויה בהעדפה אישית, אלא יש תשובה אחת נכונה בלבד. התשובה נובעת מהבנת הציפיות הסבירות של הלקוח (המחלקה שקוראת ל-playTurn) והמשתמש/ת (מי שמשחק/ת במשחק המדהים שלכם).

אם אתם מתלבטים לגבי ההתנהגות או החתימה הנכונות של playTurn בפרק טיפים למימוש תוכלו למצוא תשובות מפורטות.

מתודת playTurn: תפקוד וחתימה
בפרק ה-API דיברנו הרבה על מתודה playTurn שתקבל לוח וסימון. גם שאלנו שם - מה צריך לקרות אם הוכנסו קואורדינטות לא טובות ע"י המשתמש/ת? הן יכולות להיות קואורדינטות מחוץ ללוח או כאלה של תא תפוס - זה לא משנה - בכל מקרה Board.putMark צריכה להחזיר false.

מנקודת המבט של המשתמש/ת (הייצור החי שמשתמש בתוכנית): אולי היתה לו שגיאת כתיב, אולי היא התבלבלה. אולי סתם היה בא להם להציק לתוכנה המסכנה שלנו. מה שלא יהיה, הם בכל מקרה לא מצפים שהתוכנה תקרוס - נכון? ודי בטוח שהם גם לא מצפים שהמשחק פשוט יבחר תא פנוי רנדומלי וישים בו את הסימון היקר שלהם. הם מצפים שהתוכנית תתנהג כמו כל תוכנית שהם משתמשים בה בדר"כ - תעדכן שהקלט לא חוקי ותבקש להזין קלט חדש. אם גם אז נופלת טעות, הם מצפים שהתוכנית תחזור על הבקשה שוב, ושוב.

מבחינת מימוש, תוכלו לשאול את עצמכם: האם playTurn צריכה להתמודד מצב כזה לבד או שהיא צריכה ליפול (כלומר להחזיר למתודה שקראה לה ערך שמודיע על כשלון), ולתת למתודה הקוראת להתמודד עם המצב?

נסתכל על זה מנקודת מבטה של המתודה שקוראת ל-playTurn: מבחינתה, Player מכומס בקפסולה. המידע שלו נסתר ממנה, ובצדק. המתודה הקוראת לא יודעת אם השחקן משתמש באלגוריתם מסוים כדי לבצע את תורו, או שהוא שואל את המשתמש/ת, או שהוא עושה קסם. אין לה שום כלים להתמודד עם השגיאה הזו: כל מה שהיא יכולה לעשות זה לקרוא ל-playTurn שוב ושוב ולקוות שהפעם היא תעבוד בהצלחה. מתודות לא אוהבות לקוות לטוב. מבחינת הלקוחות של playTurn, יכול להיות שהיא אף פעם לא תצליח. במקרה כזה, צריך לקרוא לה אינסוף פעמים? לסגור את התוכנית אחרי מספר מסוים של נסיונות? בלי לדעת מה שורש הבעיה ואף פרט לגבי המימוש, מי שכותב/ת את הקוד של הלקוחה (המתודה הקוראת) לא יכול/ה להגיע להחלטה מושכלת.

ולכן, ברור שהאחריות של playTurn צריכה להיות ביצוע תור יחיד בהצלחה; היא לא צריכה לחזור בלי להשלים משימה זו. אז ל-playTurn צריכה להיות לולאה שמבקשת קלט מהמשתמש/ת כל עוד הקלט הקודם היה לא תקין.

מסקנה נוספת היא של-playTurn בעצם אין מידע למסור למתודה שקראה לה. היא לא צריכה להודיע במפורש שהיא הצליחה משתי סיבות: 1) היא חייבת תמיד להצליח, 2) המתודה שקראה לה לא תדע מה לעשות במקרה של כשלון. אז הגענו לשתי המתודות הבאות ב-player:

public Player()i
public void playTurn(Board board, Mark mark)i
שימו לב: מה אם הלוח מלא, ולכן playTurn לא יכול להצליח בשום מצב? בינתיים, התשובה שלנו היא ש-playTurn מצפה שהלקוחות שלו יקראו לו רק אם עוד אפשר לבצע תור בהצלחה; אחרת, התוצאה שלו תהיה בלתי צפויה. בעתיד יהיו לנו דרכי תגובה טובות יותר לתרחישים שלא אמורים לקרות.

קבלת קואורדינטות מהמשתמש/ת
אה, אבל איך בכלל מקבלים ערך מספרי מהמשתמש/ת? בואו נחפש בגוגל. בזמן כתיבת שורות אלו התוצאה הראשונה היא מ-Stack Overflow, והתשובה הראשונה היא:

import  java.util.Scanner;



//...



Scanner in = new Scanner(System.in);

int num = in.nextInt();

ניזכר שבמקרה שלנו המספר שהמשתמש/ת מזינ/ה אמור להיות בעל שתי ספרות: הראשונה מציינת את השורה והשניה - את העמודה. אם הערך שהוזן נמצא ב-num, האינדקס של העמודה, בספירה שמתחילה מ-0, הוא: num%10 - 1 (הספרה הימנית ביותר פחות 1), והאינדקס של השורה הוא: num/10 - 1 (הספרה השניה מימין פחות 1). זהירות: אל תניחו שהאינדקגסים הנ"ל תקינים או מתייחסים לתא ריק על הלוח. עם זאת, לא צריך לבדוק תקינות כאן ב-Player! כמו שציינו למעלה, Board.putMark פשוט יחזיר false.

אבל רגע, מה אם הקלט הוא אפילו לא מספר, כמו "בלהבלה" במקום "34"? בתרגיל הזה אפשר להניח שזה לא יקרה, ואם כן - התוכנית שלנו פשוט תקרוס וזאת אשמת המשתמש/ת. כמובן שההתנהגות הזאת לא רצויה בעולם האמיתי - מה שנרצה שם זה שהתוכנית תעדכן שהקלט לא תקין ותבקש מהמשתמש/ת להזין אותו מחדש. אם תרצו, וכלו להחליט שאתם כן מתמודדים עם קלט לא מספרי. במקרה כזה, הסיקו (ו/או מצאו בגוגל) דרך אחת מתוך מגוון פתרונות פשוטים אפשריים לבעיה.


מימוש Player
אם סיימתם להחליט מהן החתימות של המתודות הפומביות של Player, זה זמן ללכת לממש את המחלקה!

שימו לב: זה הקוד שלכם, ואתם מוזמנים להוסיף מתודות פומביות נוספות אם הן משרתות אתכם; העיקר שתשמרו על ה-API שלכם פשוט ונקי. בפרק הטיפים יש עזרה לגבי קבלת קלט מהמשתמש/ת.


העברת מידע בין מתודות
המתודה המרכזית במחלקת Game היא:

public Mark run()

מופעי השחקנים וה-Renderer כבר נשלחו לבנאי של Game. אבל איך הם יגיעו מהבנאי למתודה run? הדרך הפשוטה ביותר לעשות זאת היא לאחסן את המידע בשדות עזר. אבל כדאי להיות מינימליים בשימוש בשדות; בדר"כ נעדיף שימוש במשתני מתודות מקומיים, ונכריז על שדות רק כשזה נדרש.

לולאת המשחק
ב-run בטח תיצרו את המופע של Board. ואז תהיה לכם לולאה שתמשיך עד שהמשחק יסתיים (איך תדעו שהמשחק הסתיים, אם נניח לרגע ש-Board כבר ממומשת במלואה?). בכל איטרציה הלוח מוצג ואחד מהשחקנים משחק את תורו. אחרי שהלולאה מסתיימת, הלוח צריך להיות מוצג עוד פעם אחת.

חשבו: מה היה קורה אם היינו מגדירים שבכל איטרציה יש הצגה של הלוח, תור של שחקן אחד ואז תור של השחקן השני?

אם אתם מקבלים את ההנחה שבכל איטרציה צריך להיות תור יחיד, עולה השאלה - איך נדע איזה שחקן ועם איזה סימון?

הדרך הפשוטה ביותר היא באמצעות מונה (counter) שעולה בכל איטרציה. אם counter%2 == 0 - השחקן playerX משחק עם X. אחרת, השחקן playerO משחק עם O. אבל במקרה שיש לנו מערכים לשחקנים ולסימונים בצורה הבאה:

Player[] players = { playerX, playerO };

Mark[] marks = { Mark.X, Mark.O };

אולי זה יאפשר לנו לשלוט בשחקן שמשחק כרגע גם בלי להשתמש בתנאי if-else? אשאיר את זה לכם. בכל מקרה, אין משהו רע ב-if-else.

אינטראקציה עם המשתמשים

שימו לב לא לתקשר (באמצעות הדפסות או קבלת קלט) עם השחקנים האנושיים ב-Game. למחלקת המשחק לא אמור לשנות אם השחקנים אנושיים או לא - הם יכולים בהמשך לא להיות (וזה גם יקרה…)!




GAME


משהו מפריע לכם?
אז כתבתם קצת קוד במחלקת Player. לא שכחתם משהו? מפריע לכם שהקוד שכתבתם עוד לא נבדק? כדאי מאוד שכן! זה הרגל טוב לחוש אי נוחות כל פעם שהקוד הלא-בדוק שלכם עולה באורכו על שיטה קצרה.

גשו למתודת ה-main שלכם. צרו לוח, שחקן, renderer, בצעו תור אחד של השחקן על הלוח (כלומר המשתמש צריך לקבל בקשה להזין קואורדינטות), והציגו את הלוח:



אולי משהו לא עובד ואתם תמצאו בקלות את הטעות ותתקנו אותה. אבל אולי לא - אתם פשוט לא בטוחים איך בדיוק לדבג את הקוד. ואם לא עכשיו, זה בטח יקרה לכם עוד המון פעמים בהמשך קריירת התכנות שמחכה לכם. זה לגמרי נורמלי, וחלק טבעי מפיתוח תוכנה, בלי קשר לרמת המקצועיות או הניסיון. נכון לעכשיו, עברו על הקוד בזהירות ונסו למצוא את הטעות. אם זה לא עובד, פנו לפרק שאלות ותשובות (לשונית אחרונה).

הבנאי של Game
אם הגעתם לשורה הזאת, כנראה שלמיטב ידיעתכם הקוד שכתבתם עד כה עובד. אז בואו נעסוק במחלקת Game. מופע של המחלקה מייצג משחק יחיד, כלומר תהליך שמתחיל מלוח חלק ועד לנצחון/תיקו. מה יהיו התכונות שמזהות משחק במצבו הראשוני, שיפרידו בינו לבין משחקים אחרים? במילים אחרות, מה הבנאי יצטרך לדרוש כפרמטרים?

ראשית, המחלקה Game צריכה אובייקט Renderer כדי להציג את הלוח. כן, טכנית Game יכולה ליצור את ה-renderer משלה בעצמה, אבל בתרגילים מתקדמים יותר נראה את היתרון בקבלת עצם על פני יצירה שלו; קבלת ה-renderer כפרמטר תאפשר לנו לבצע שינויים במנגנון התצוגה בלי לשנות את Game.

במה עוד תלוי משחק יחיד?

בהתחשב בכך שבעתיד מופע של שחקן יכול לייצג גם שחקן לא אנושי, ניתן להגיד שאחת מתכונות המשחק היא סוג השחקנים שמשתתפים בו. המשמעות היא שמופעי השחקנים צריכים להיווצר לפני המשחק, ולהישלח לבנאי שלו כפרמטרים. גם כאן, יצירת השחקנים מחוץ למחלקת Game תאפשר לנו להרחיב את הפונקציונליות של התוכנית שלנו בהמשך.

אז חתימת הבנאי שלנו יכולה להיראות כך:

public Game(Player playerX, Player playerO, Renderer renderer)

Game.run
נסתכל על המחלקה מנקודת המבט של לקוחותיה, כלומר "העולם החיצוני" - שכרגע הוא מתודת ה-main בלבד.

רגע רגע, מה? main היא הלקוחה של Game? אבל main נמצאת בעצמה בתוך מחלקת Game! אז זהו, טכנית - אתם צודקים. אבל main היא מתודה מיוחדת - היא לא חלק מה-API של המחלקה שבה היא כתובה, היא פשוט הדרך שלנו להניע את תחילת התוכנית. main תמיד יכולה לעבור למחלקה אחרת (ספוילר - זה גם יקרה בהמשך…) בלי לשנות את תפקיד המחלקה.

אז מהצד של main, מופע של Game מייצג משחק יחיד, שמאותחל עם שני מופעי Player ומופע Renderer. בנוסף, main צריכה דרך לגרום למשחק להתחיל - נקרא למתודה הזו run.

איך אתם חושבים שהחתימה של run צריכה להיראות?

ראשית, לגבי הקלט (רשימת הפרמטרים): נכון ש-run זקוקה לשחקנים, אבל הלקוחה (main) כבר סיפקה אותם כשקראה לבנאי ולכן לא מצפה להזין אותם שוב.

לגבי הפלט: זכרו שמופע של Game מייצג משחק יחיד. זה די הגיוני להניח שהלקוחה שלנו תרצה לדעת מי ניצח את המשחק! לדוגמה, באופן היפותטי, ממש דוגמה שהומצאה הרגע ולא קשורה בכלל לתרגיל הבא - אם נרצה לערוך תחרות בת 100 משחקים בין שני שחקנים, נרצה לעקוב אחרי מספר הניצחונות של כל שחקן.

עבור מחלקת Board כבר הגדרתם enum ייעודי להכרזת המנצח. נוכל להשתמש באותו enum כערך החזרה של Game.run.

מימוש Game
דמיינו שהבנאי של Game ומתודת run כבר כתובות. מה מתודת main צריכה לכלול? רמז: היא מאוד קצרה. אז בואו נתחיל במימוש של main.  כדי לבדוק אותה, נצטרך stub-ים של הבנאי של Game ושל run. מתודת ה-run שלכם יכולה לדוגמה לחזור מיידית עם הכרזה ש-X הוא המנצח.

חזרו לכאן אחרי שמימשתם את main והרצתם את התוכנית (שלא באמת תפעיל את המשחק עצמו היות ו-run היא רק stub).



למה חזרתם? עכשיו הכל כבר מוכן למימוש מלא של מחלקת Game! לכו על זה. אם אתם לא בטוחים לגבי המימוש של run, היעזרו בפרק הטיפים.




אז, מה כבר יש לנו? בתקווה, משחק שלם שעובד, חוץ מהעובדה שאי אפשר לנצח בו - המשחק לא נגמר לעולם, גם אם הלוח מלא:



טוב, ייתכן שצריך רופא בשביל חוות דעת שניה, אבל אולי זה בגלל שב-Board יש stubs במקום מימוש שבאמת בודק אם המשחק נגמר או לא. אם קיבלתם את ההצעה לכתוב את ה-API הנדרש של Board כהערה בקובץ, אז תוכלו לראות מה עוד נשאר לממש מתוך מה שתוכנן.

עכשיו יהיה זמן מעולה לממש את הפונקציונליות הזאת. לא הגדרנו לכם מה המתודה/ות שאחראיות לבדוק ולהחזיר אם המשחק נגמר ואיך - זה נתון לבחירתכם. אבל מה שלא תבחרו, אין צורך שהן עצמן תעשינה מעבר על הלוח. נשמע הגיוני שכשנסמן סימון חדש על הלוח ב-putMark גם נבדוק באותה הזדמנות אם הוא השלים רצף באורך הנדרש (או מילא את המקום האחרון בלוח), בלי שנצטרך לעבור על כל הלוח. אם אתם לא בטוחים מה הכוונה או איך לממש דבר כזה, העיפו מבט בפרק טיפים למימוש.



אם סיימתם לממש את כל מה שצריך ב-Board, הלולאה ב-Game.run צריכה (באופן תיאורטי) פשוט לעצור כשהמשחק נגמר. אחריה, בטח תרצו להודיע לשחקנים מי ניצח בצורה שתבחרו.

כחלק מאיזו מתודה ההודעה הזו צריכה להיות לדעתכם: Game.run או Game.main? זה תלוי אם הדפסת התוצאה היא חלק אינטגרלי מהמשחק או שהיא נדרשת רק בצורה הספציפית שבה אנחנו משתמשים כרגע ב-Game. חישבו על כך שבפעם הבאה שנעסוק בתרגיל הזה אנחנו נערוך תחרות שבה נבצע מספר גדול של משחקים.

הוסיפו את הודעת הנצחון וחזרו לכאן.



הוספתם את ההודעה? אז זהו, סיימנו! מזל טוב! בטח המשחק שלכם מושלם וחסר באגים! כאילו -- למה שלא יהיה? ספציפית, ברור שהוא:

מזהה ניצחון של אחד מהצדדים.
מזהה תיקו.
מזהה רצפים שכוללים תאים בקצוות הלוח (שורה/עמודה ראשונה ואחרונה).
מכריז על נצחון כאשר מוסיפים סימון בתא האחרון הפנוי, שגם משלים רצף.
כאשר הוזנו קואורדינטות לא חוקיות, הוא מבקש להזין קואורדינטות חדשות.
מבקש בפעם השניה אם שוב הוזנו קואורדינטות לא חוקיות וחוזר חלילה.
מתכנתים שמניחים שהקוד שלהם עובד כנראה טועים. מתכנתים שמניחים שיש להם טעויות בקוד כנראה צודקים אבל יש להם סיכוי יותר גבוה... לטעות? בכל מקרה, פשוט בדקו את הקוד שלכם.

