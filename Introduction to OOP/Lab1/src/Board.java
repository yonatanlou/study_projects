enum Mark {BLANK, X, O}
public class Board {
    public static final int SIZE = 6;
    public static final int WIN_STREAK = 5;

    public Board() {
//        אתם בטח זוכרים שמחלקת Renderer, שכבר כתובה, תלויהב-Board, מה שאומר שיש לה כמה הנחות לגבי ה-API של Board. ספציפית, כדי להתקמפל, Renderer דורשת ששלושה דברים יתקיימו:
//
//        קיים enum בשם Mark, ויש בו (לפחות) את הערכים הבאים: X, O, BLANK.
//                מוגדר משתנה בשם Board.SIZE.
//                ב-Board יש מתודה public Mark getMark(int row, int col)i.
    }

//    אז עברנו על שלושת התפקידים המרכזיים של הלוח. אבל נצטרך עוד שני דברים:
//
//    הלקוחות צריכים לדעת מהו גודל הלוח ומה אורכו של רצף מנצח (כלומר מהם N ו-K)
//    ייצור הלוח (בנאי)
//    כדי להקל נגדיר את N ו-K כקבועים. קבועים אלו מגדירים תכונות של הלוח וכל משתמש בלוח יכול להזדקק להם, ולכן נגדיר אותם במחלקת לוח כך:
//
//    השתמשו באילו SIZE/WIN_STREAK שתבחרו. תוכלו לשנות אותם לחוויות משחק שונות. size קטן יותר יכול להיות שימושי לחלק מהדיבוגים.


    boolean putMark(Mark mark, int row, int col) {
        //put mark
//        1/1 point (ungraded)
//        ניצור מתודה לסימון על הלוח, שיכולה להיקרא putMark. המתודה צריכה לקבל כקלט את הסימון והקואורדינטות שבהן צריך לסמן אותו.
//
//                האם לפעולה זו יש פלט? במבט ראשון לא - מה היא תחזיר ללקוח שלה? היא רק משנה את המצב הפנימי של הלוח עצמו! אבל בואו נוודא שכיסינו את כל המקרים האפשריים: מה אם הקלט לא חוקי? לדוגמה, קואורדינטות שלילות, מחוץ לגבולות הלוח, או של תא שכבר מסומן. אנחנו צריכים לדווח ללקוח של המחלקה אם הפעולה הצליחה או נכשלה. הסימון המקובל הוא true להצלחה ו-false לכשלון.
//
//                אז איך תראה חתימת המתודה putMark?

        return true;
    }

//    enum GameStatus() {
        //        המחלקה צריכה לדווח אם המשחק נגמר ובאיזו תוצאה - ניצחון של X, של O או בתיקו.
//
//        אפשר לבצע זאת בכמה דרכים, ואתם יכולים לבחור את הדרך שנראית לכם המתאימה ביותר. לדוגמה, אפשר להפריד את הפונקציונליות הזו לשתי מתודות: אחת היא פונקציה בוליאנית שמהווה אינדיקציה אם המשחק נגמר (boolean isGameEnded), ואחת שתחזיר את המנצח (באמצעות enum שנקרא Winner ויכול להיות אחד מהבאים: DRAW, X_WIN, Y_WIN).
//
//        אפשר גם לממש מתודה בודדת שתחזיר enum בשם GameStatus עם ארבעה ערכים אפשריים: DRAW, X_WIN, O_WIN או IN_PROGRESS.
//
//        בכל דרך שתבחרו, הימנעו מגישה פומבית לשדה הבוליאני שמסמל את תום המשחק, אלא אפשרו גישה למתודה/ות בלבד, כדי למנוע את שינוי הנתונים ע"י מחלקות חיצוניות. תמיד עדיף לדעת מי בדיוק יכול לשנות את ערכי המשתנים ובאילו מצבים.    }
//    }

        public Mark getMark(int row, int col) {
//            אבל רגע! מה אם הקואורדינטות שהיא מקבלת כקלט אינן חוקיות? בתרגילים מתקדמים יותר נתמודד עם מקרה כזה בצורה שונה, אבל נכון לעכשיו נסתפק בהחזרת null במקרה כזה. שימו לב שזה לא שקול להנחה שהקואורדינטות חוקיות.
        return Mark.BLANK;
    }

        }








//    מחלקת Board: טיפים למימוש epsilon-functionality
//
//        מטרת הפרק הזה היא לעזור לכם להגיע לגרסה של מחלקת Board בעלת:
//
//        בנאי
//        מתודות putMark ו-getMark פועלות
//        קבועי SIZE ו-WIN_STREAK
//        זה לא כל מה שאנחנו צריכים מהמחלקה, אבל זאת התחלה! וממנה נתקדם לאט לאט עד לקוד המלא, כשבכל שלב בדרך הקוד שלנו יעבוד.
//
//        בואו נתחיל מ-putMark ו-getMark. נשים לב שהם צריכים דרך "לתקשר": X ששמנו על הלוח בעזרת putMark בקואורדינטות מסוימות יחזור באמצעות getMark עבור אותן קואורדינטות. אפשר לממש זאת בעזרת שדות פרטיים.
//
//        איזה סוג של שדה יאפשר לנו לשמור את מה שנשלח ל-putMark? איך נאתחל אותו ואיפה?
//
//        תזכורת לגבי הכרזה על שדות:
//        תזכורת לגבי הכרזה על שדות: כדי להכריז על שדה ב-Java, צריך להכריז באופן מפורש על הנראות, הסוג והשם שלו (ואפשר גם על ערכו ההתחלתי), בתוך המחלקה ולא בתוך אף מתודה. בזה Java שונה מהרבה שפות דינמיות כמו Python. המילה השמורה this לא קשורה להכרזה על המשתנה: ניתן להשתמש בה רק כדי לגשת למשתנה שכבר הכריזו עליו.
//
//public boolean putMark(Mark mark, int row, int col)i
//        אחרי ההחלטה על השדה שבו יישמר הסימון על הלוח ב-putMark, מימוש המתודה יראה מאוד טריוויאלי. אבל כמתודה פומבית לא ניתן להניח שהקלט שלה יהיה תקין. אם הקואורדינטות שקיבלה לא חוקיות, המתודה צריכה להיכשל (באמצעות החזרה של false). זה צריך להיראות בערך ככה:
//
//
//
//        באופן דומה, המתודה צריכה להיכשל כאשר היא מקבלת קואורדינטות של תא שכבר יש בו X או O. אחרי שתוודאו שהקלט תקין, תוכלו לאחסן את הסימון שהתקבל לשימוש עתידי.
//
//public Mark getMark(int row, int col)
//
//        שוב, גם המתודה הזו לא יכולה להניח שהקלט שלה חוקי! במקרה שלנו, אם הוזנו קואורדינטות לא חוקיות המתודה צריכה להחזיר Mark.BLANK. אם הקואורדינטות חוקיות, השתמשו במידע שיש לכם לגבי תוכן הקואורדינטות כדי להחזיר את הסימון שנמצא בהן.
//
//        ()public Board
//
//        זו אחריותו של הבנאי לוודא שהאובייקט נמצא במצב ראשוני תקין, כלומר לאתחל את שדות האובייקט לערכים הראשוניים המתאימים.
//
//        SIZE & WIN_STREAK
//
//        זה החלק הקל - הוסיפו את הקבועים הבאים למחלקה שלכם:
//
//
//
//        כמובן שאתם יכולים להתחיל עם כל שני ערכים אחרים, לדוגמה 3 ו-3.
//
//        זהו! אה - אתם זוכרים לקמפל כל שתי שורות, כן?
